// Challenge 56: RC4 Single-Byte Biases

package main

import (
	"bytes"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"log"
	"math/big"
	"tools"
)

func pow(a, b int) int {
	p := 1
	for b > 0 {
		if b&1 != 0 {
			p *= a
		}
		b >>= 1
		a *= a
	}
	return p
}

var (
	p, g, q, j, x *big.Int
)

func init() {
	var ok bool
	p, ok = new(big.Int).SetString("7199773997391911030609999317773941274322764333428698921736339643928346453700085358802973900485592910475480089726140708102474957429903531369589969318716771", 10)
	g, ok = new(big.Int).SetString("4565356397095740655436854503483826832136106141639563487732438195343690437606117828318042418238184896212352329118608100083187535033402010599512641674644143", 10)
	q, ok = new(big.Int).SetString("236234353446506858198510045061214171961", 10)
	j, ok = new(big.Int).SetString("30477252323177606811760882179058908038824640750610513771646768011063128035873508507547741559514324673960576895059570", 10)
	if !ok {
		panic("some big number was not ok")
	}
	// secret exponent generated by Bob
	x = new(big.Int).SetBytes(tools.RandBytes(2024))
	x.Mod(x, q)
}

func genPrimes(n int64) []int64 {
	p := make([]int64, 0)
	sieve := make(map[int64]bool)
	for i := int64(2); i < n; i++ {
		sieve[i] = true
	}
	for i := int64(2); i < n; i++ {
		if sieve[i] {
			p = append(p, i)
			for j := i + i; j < n; j = j + i {
				sieve[j] = false
			}
		}
	}
	return p
}

func MAC(key, msg []byte) []byte {
	h := hmac.New(sha256.New, key)
	h.Write(msg)
	return h.Sum(nil)
}

func msgFromBob(h *big.Int) (msg, mac []byte) {
	k := new(big.Int).Exp(h, x, p)
	msg = []byte("crazy flamboyant for the rap enjoyment")
	mac = MAC(k.Bytes(), msg)
	return msg, mac
}

func main() {

	primes := genPrimes(0x10000)
	// fmt.Println(primes)
	divs := make([]int64, 0)
	for _, p := range primes {
		rem := new(big.Int).Rem(j, big.NewInt(p))
		if rem.Sign() == 0 {
			divs = append(divs, p)
		}
	}

	fmt.Println(divs)

	pMinus1 := new(big.Int).Sub(p, big.NewInt(1))
	one := big.NewInt(1)
	for _, r := range divs {
		// generate h of order r
		var h *big.Int
		for {
			num, err := rand.Int(rand.Reader, p)
			if err != nil {
				log.Fatal(err)
			}
			exp := new(big.Int).Div(pMinus1, big.NewInt(r))
			h = new(big.Int).Exp(num, exp, p)
			if h.Cmp(one) != 0 {
				break
			}
		}
		fmt.Printf("r = %d\n", r)
		// send h to BOB and get signed msg from him
		m, t := msgFromBob(h)
		// find x mod r
		for x := int64(0); x < r; x++ {
			k := new(big.Int).Exp(h, big.NewInt(x), p)
			macGuess := MAC(k.Bytes(), m)
			if bytes.Equal(t, macGuess) {
				fmt.Printf("x = %+v\n", x)
				break
			}
		}
		fmt.Println("")
	}

}
